<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    <script>
        //연결 리스트 기본 형태
        const list = {
            head: {
                value : 12,
                next : {
                    value : 99,
                    next : {
                        value: 37,
                        next: null
                    }
                }
            }
        }

        //문제 35를 출력하라
        const list2 = {
            head: {
                value: 90,
                next: {
                    value: 2,
                    next: {
                        value: 77,
                        next: {
                            value: 35,
                            next: {
                                value: 21,
                                next: null                            }
                        }
                    }
                }
            }
        }
       // list2.head.next.next.next.value => 35 출력

       //class로 표현
       //step1 - 노드 생성
       class Node {
           constructor(data){
               this.data = data
               this.next = null
           }
       }

       노드1 = new Node(10)
       노드2 = new Node(20)
       노드3 = new Node(30)

       노드1.data
       노드1.next = 노드2
       노드2.next = 노드3
       노드1.next.next.data

       //step2 - 자동으로 다음 노드가 연결되는  linked list 구현

       class Node {
           constructor(data){
               this.data = data
               this.next = null
           }
       }

       class LinkedList{
           constructor(){
               let init = new Node('init');
               this.head = init
               this.tail = init
           }
           append(data){
               let 새로운노드 = new Node(data)
               this.tail.next = 새로운노드
               this.tail = 새로운노드           
           }
       }

       l = new LinkedList()
       1.append(1)
       1.append(2)
       1.append(3)
       1.append(10)
       1.append(20)
       1.append(30)

       //1.head
       //1.head.next.data => 1
       //1.head.next.next.data => 2
       //1.head.next.next.next.data => 3

       //step3
       class Node {
    constructor(data){
        this.data = data
        this.next = null
    }
}

class LinkedList {
    constructor(){
        let init = new Node('init')
        this.head = init
        this.tail = init

        this.데이터수 = 0
    }

    length(){
        return this.데이터수
    }
    
    append(data){
        let 새로운노드 = new Node(data)
        this.tail.next = 새로운노드
        this.tail = 새로운노드

        this.데이터수 += 1
    }
}

l = new LinkedList()
l.append(1)
l.append(2)
l.append(3)
l.append(10)
l.append(20)
l.append(30)
l.length()

// step 4 toString 구현

class Node {
    constructor(data){
        this.data = data
        this.next = null
    }
}

class LinkedList {
    constructor(){
        let init = new Node('init')
        this.head = init
        this.tail = init

        this.데이터수 = 0
        this.데이터들 = ''
    }

    length(){
        return this.데이터수
    }

    toString(){
        // return 'hello world'
        // return '[1, 2, 3, 10, 20, 30]'
        
        // 아래와 같이 구현했을 때 삭제가 문제가 됩니다.
        return '[' + this.데이터들.slice(0, -2) + ']'

    }
    
    append(data){
        let 새로운노드 = new Node(data)
        this.tail.next = 새로운노드
        this.tail = 새로운노드

        this.데이터수 += 1
        this.데이터들 += `${data}, `
    }
}

l = new LinkedList()
l.append(1)
l.append(2)
l.append(3)
l.append(10)
l.append(20)
l.append(30)
l.length()


//step7 - 새로운 노드 삽입
class Node {
    constructor(data){
        this.data = data
        this.next = null
    }
}

class LinkedList {
    constructor(){
        let init = new Node('init')
        this.head = init
        this.tail = init

        this.데이터수 = 0
    }

    length(){
        return this.데이터수
    }

    toString(){
        let 순회용현재노드 = this.head
        순회용현재노드 = 순회용현재노드.next

        let 데이터들 = ''
        for (let i = 0; i < this.데이터수; i++) {
            데이터들 += `${순회용현재노드.data}, `
            순회용현재노드 = 순회용현재노드.next
        }

        return '[' + 데이터들.slice(0, -2) + ']'
    }

    // data를 얻기 위한 메서드, data를 넣기 위한 메서드는 getter와 setter를 사용을 권고합니다.
    fullData(){
        return JSON.parse(this.toString())
    }
    
    append(data){
        let 새로운노드 = new Node(data)
        this.tail.next = 새로운노드
        this.tail = 새로운노드

        this.데이터수 += 1
    }

    insert(index, data){
        let 순회용현재노드 = this.head
        순회용현재노드 = 순회용현재노드.next

        for (let i = 0; i < index - 1; i++) {
            순회용현재노드 = 순회용현재노드.next
        }

        let 새로운노드 = new Node(data)
        새로운노드.next = 순회용현재노드.next
        순회용현재노드.next = 새로운노드

        this.데이터수 += 1
    }
}

l = new LinkedList()
l.append(1)
l.append(2)
l.append(3)
l.append(10)
l.append(20)
l.append(30)
l.length()
l.toString()
console.log(l.fullData())
l.insert(3, 1000)
console.log(l.fullData())
    

//더블 링크드 리스트의 기본 형태

const list = {
    head: null
}

let list1 = {value:12, next:null, pre:null}
let list2 = {value: 99, next: null, pre:null}
let list3 = {value:37, next: null, pre:null}
let list4 = {value: }    
   
//3. 정렬
//3.1 선택정렬
let 입력값 = [199, 22, 33, 12, 32, 64, 72, 222, 233]
let 정렬된배열 = []
let 길이 = 입력값.length

// 주의해야 할 사항 : pop을 하면 length가 줄어듭니다!
// for (let i = 0; i < 입력값.length; i++) {
//     console.log(입력값.pop())
//     console.log(i)   
// }

for (let i = 0; i < 길이; i++) {
    let 최솟값 = Math.min(...입력값);
    정렬된배열.push(최솟값)
    입력값.splice(입력값.indexOf(최솟값), 1)
}


//3.2 삽입정렬(자기가 들어갈 위치를 찾아감)
let 전 = [199, 22, 33, 12, 32, 64, 72, 222, 233];
let 후 = [];

let 입력값 = [199, 22, 33, 12, 32, 64, 72, 222, 233];
let 정렬된배열 = [];
let 배열의길이 = 입력값.length;

function 삽입값이_들어갈_인덱스(정렬된배열, 삽입값){
    for (const i in 정렬된배열) {
        if(삽입값<정렬된배열[i]){
            return i
        }
    }
}

for(let i = 0; i < array.length; i++){
    let 삽입값 = 입력값.shift()
    let 인덱스 = 삽입값이_들어갈_인덱스(정렬된배열, 삽입값)
    정렬된배열.splice(인덱스, 0, 삽입값)
}

console.log(정렬된배열);

//
let 입력값 = [5, 10, 66, 77, 54, 32, 11, 15];

function 병합정렬(입력배열){
    let 입력배열의길이 = 입력배열.length
    let 결과값 = []

    if (입력배열의길이 <= 1) {
        return 입력배열
    }

    let 중간값 = parseInt(입력배열의길이 / 2)
    let 그룹하나 = 병합정렬(입력배열.slice(0, 중간값))
    let 그룹둘 = 병합정렬(입력배열.slice(중간값))
    
    while (그룹하나.length != 0 && 그룹둘.length != 0){
        if (그룹하나[0] < 그룹둘[0]){
            결과값.push(그룹하나.shift())
        } else {
            결과값.push(그룹둘.shift())
        }
    }

    while (그룹하나.length != 0){
        결과값.push(그룹하나.shift())
    }

    while (그룹둘.length != 0){
        결과값.push(그룹둘.shift())
    }

    return 결과값
    
}

console.log(병합정렬(입력값))
</script>
   
</body>
</html>